Key Advantages of These Methods Over CUSUM:

Changepoint Detection (Ruptures): More sophisticated algorithms (PELT) that can detect multiple changepoints simultaneously with better statistical foundation
Statistical Tests: Directly tests for mean and variance shifts using robust statistical methods, more sensitive to gradual changes
EWMA Control Charts: Superior for detecting small persistent shifts that CUSUM might miss, commonly used in manufacturing
Time Series Clustering: Identifies different operational regimes, useful for understanding mode changes in production
Consensus Approach: Reduces false positives by requiring agreement between methods

Why These Are Better for Manufacturing Data:

Multiple validation: Consensus approach reduces false alarms
Gradual shift detection: Statistical tests and EWMA excel at this
Operational context: Clustering identifies different production modes
Lag handling: Can be easily extended to incorporate your material/pre-step lags
Product-specific: Each product type analyzed separately as requested

The consensus approach is particularly valuable for operations teams as it provides higher confidence shifts that multiple methods agree upon, reducing the noise inherent in single-method approaches.




import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
import ruptures as rpt
from statsmodels.tsa.stattools import adfuller
from statsmodels.stats.diagnostic import het_white
import warnings
warnings.filterwarnings('ignore')

class ShiftDetectionSuite:
    """
    Comprehensive shift detection for manufacturing data with multiple methods
    """
    
    def __init__(self, df, target_vars, date_col='GMT Prod Yield Date', product_col='Merge'):
        self.df = df.copy()
        self.target_vars = target_vars
        self.date_col = date_col
        self.product_col = product_col
        self.shift_results = {}
        
    def detect_all_shifts(self, products=None, methods=['changepoint', 'statistical', 'ewma', 'clustering']):
        """Apply multiple shift detection methods"""
        if products is None:
            products = self.df[self.product_col].unique()
            
        for product in products:
            self.shift_results[product] = {}
            product_data = self.df[self.df[self.product_col] == product].copy()
            
            if len(product_data) < 20:  # Skip products with insufficient data
                continue
                
            for target in self.target_vars:
                if target not in product_data.columns:
                    continue
                    
                series = product_data.set_index(self.date_col)[target].dropna()
                if len(series) < 20:
                    continue
                
                self.shift_results[product][target] = {}
                
                # Apply each method
                if 'changepoint' in methods:
                    self.shift_results[product][target]['changepoint'] = self._changepoint_detection(series)
                
                if 'statistical' in methods:
                    self.shift_results[product][target]['statistical'] = self._statistical_tests(series)
                
                if 'ewma' in methods:
                    self.shift_results[product][target]['ewma'] = self._ewma_control(series)
                    
                if 'clustering' in methods:
                    self.shift_results[product][target]['clustering'] = self._time_series_clustering(series)
    
    def _changepoint_detection(self, series, methods=['pelt', 'window']):
        """
        Ruptures library changepoint detection - excellent for manufacturing data
        PELT (Pruned Exact Linear Time) for multiple changepoints
        """
        results = {'shifts': [], 'method': 'changepoint', 'scores': []}
        
        try:
            # Convert to numpy array
            signal = series.values
            
            # PELT algorithm for multiple changepoints
            algo_pelt = rpt.Pelt(model="rbf", min_size=5, jump=1).fit(signal)
            changepoints_pelt = algo_pelt.predict(pen=10)
            
            # Remove the last point (end of series)
            if changepoints_pelt and changepoints_pelt[-1] == len(signal):
                changepoints_pelt = changepoints_pelt[:-1]
            
            # Convert to dates
            pelt_dates = [series.index[cp] for cp in changepoints_pelt if cp < len(series)]
            
            # Window-based detection for comparison
            algo_window = rpt.Window(width=10, model="l2").fit(signal)
            changepoints_window = algo_window.predict(n_bkps=3)
            if changepoints_window and changepoints_window[-1] == len(signal):
                changepoints_window = changepoints_window[:-1]
            
            window_dates = [series.index[cp] for cp in changepoints_window if cp < len(series)]
            
            results['shifts'] = {
                'pelt': pelt_dates,
                'window': window_dates,
                'combined': list(set(pelt_dates + window_dates))
            }
            results['scores'] = {'pelt_penalty': 10, 'n_changepoints': len(pelt_dates)}
            
        except Exception as e:
            results['error'] = str(e)
            
        return results
    
    def _statistical_tests(self, series, window_size=15):
        """
        Statistical shift detection using t-tests and variance tests
        More sensitive than CUSUM for gradual shifts
        """
        results = {'shifts': [], 'method': 'statistical', 'test_stats': []}
        
        try:
            values = series.values
            dates = series.index
            shifts = []
            test_stats = []
            
            for i in range(window_size, len(values) - window_size):
                # Before and after windows
                before = values[i-window_size:i]
                after = values[i:i+window_size]
                
                # T-test for mean shift
                t_stat, t_p = stats.ttest_ind(before, after, equal_var=False)
                
                # F-test for variance shift
                f_stat = np.var(after, ddof=1) / np.var(before, ddof=1)
                f_p = 1 - stats.f.cdf(f_stat, len(after)-1, len(before)-1)
                
                # Combined test
                if t_p < 0.01 or f_p < 0.01:  # Significant shift
                    shifts.append(dates[i])
                    test_stats.append({
                        'date': dates[i],
                        't_stat': t_stat,
                        't_p': t_p,
                        'f_stat': f_stat,
                        'f_p': f_p,
                        'shift_magnitude': np.mean(after) - np.mean(before)
                    })
            
            results['shifts'] = shifts
            results['test_stats'] = test_stats
            
        except Exception as e:
            results['error'] = str(e)
            
        return results
    
    def _ewma_control(self, series, lambda_ewma=0.2, threshold_sigma=3):
        """
        Exponentially Weighted Moving Average control chart
        Better than CUSUM for detecting small persistent shifts
        """
        results = {'shifts': [], 'method': 'ewma', 'control_stats': {}}
        
        try:
            values = series.values
            dates = series.index
            
            # Calculate EWMA
            ewma = np.zeros(len(values))
            ewma[0] = values[0]
            
            for i in range(1, len(values)):
                ewma[i] = lambda_ewma * values[i] + (1 - lambda_ewma) * ewma[i-1]
            
            # Control limits
            overall_mean = np.mean(values)
            overall_std = np.std(values)
            
            # EWMA variance (theoretical)
            ewma_var = []
            for i in range(len(values)):
                var_i = (overall_std**2) * (lambda_ewma / (2 - lambda_ewma)) * (1 - (1 - lambda_ewma)**(2*(i+1)))
                ewma_var.append(var_i)
            
            ewma_std = np.sqrt(ewma_var)
            ucl = overall_mean + threshold_sigma * ewma_std
            lcl = overall_mean - threshold_sigma * ewma_std
            
            # Detect shifts
            shifts = []
            for i in range(1, len(ewma)):
                if ewma[i] > ucl[i] or ewma[i] < lcl[i]:
                    shifts.append(dates[i])
            
            results['shifts'] = shifts
            results['control_stats'] = {
                'ewma': ewma,
                'ucl': ucl,
                'lcl': lcl,
                'center_line': overall_mean,
                'lambda': lambda_ewma
            }
            
        except Exception as e:
            results['error'] = str(e)
            
        return results
    
    def _time_series_clustering(self, series, n_clusters=3, window_size=10):
        """
        Time series clustering approach to identify regime changes
        Useful for identifying different operational modes
        """
        results = {'shifts': [], 'method': 'clustering', 'cluster_info': {}}
        
        try:
            values = series.values
            dates = series.index
            
            # Create sliding windows as features
            windows = []
            window_dates = []
            
            for i in range(window_size, len(values)):
                window = values[i-window_size:i]
                windows.append([
                    np.mean(window),
                    np.std(window),
                    np.max(window) - np.min(window),
                    np.percentile(window, 75) - np.percentile(window, 25)
                ])
                window_dates.append(dates[i])
            
            if len(windows) < n_clusters:
                results['error'] = 'Insufficient data for clustering'
                return results
            
            # Standardize features
            scaler = StandardScaler()
            windows_scaled = scaler.fit_transform(windows)
            
            # K-means clustering
            kmeans = KMeans(n_clusters=n_clusters, random_state=42, n_init=10)
            clusters = kmeans.fit_predict(windows_scaled)
            
            # Find cluster transitions (shifts)
            shifts = []
            for i in range(1, len(clusters)):
                if clusters[i] != clusters[i-1]:
                    shifts.append(window_dates[i])
            
            results['shifts'] = shifts
            results['cluster_info'] = {
                'clusters': clusters,
                'cluster_centers': kmeans.cluster_centers_,
                'silhouette_score': silhouette_score(windows_scaled, clusters),
                'n_clusters': n_clusters
            }
            
        except Exception as e:
            results['error'] = str(e)
            
        return results
    
    def consensus_shifts(self, product, target, min_methods=2):
        """
        Find shifts detected by multiple methods (consensus approach)
        """
        if product not in self.shift_results or target not in self.shift_results[product]:
            return []
        
        all_shifts = []
        method_data = self.shift_results[product][target]
        
        # Collect all shift dates from different methods
        for method_name, method_result in method_data.items():
            if 'shifts' in method_result:
                if method_name == 'changepoint':
                    # Use combined changepoint results
                    shifts = method_result['shifts'].get('combined', [])
                elif isinstance(method_result['shifts'], list):
                    shifts = method_result['shifts']
                else:
                    continue
                all_shifts.extend(shifts)
        
        if not all_shifts:
            return []
        
        # Convert to pandas datetime for easier handling
        shift_series = pd.to_datetime(all_shifts)
        
        # Group shifts within 7 days of each other
        consensus_shifts = []
        tolerance = pd.Timedelta(days=7)
        
        shift_groups = []
        used_shifts = set()
        
        for shift in shift_series:
            if shift in used_shifts:
                continue
            
            # Find all shifts within tolerance
            nearby_shifts = shift_series[abs(shift_series - shift) <= tolerance]
            
            if len(nearby_shifts) >= min_methods:
                consensus_shifts.append(shift)
                used_shifts.update(nearby_shifts)
        
        return sorted(consensus_shifts)
    
    def plot_comparison(self, product, target, save_plots=True):
        """
        Plot comparison of all shift detection methods
        """
        if product not in self.shift_results or target not in self.shift_results[product]:
            print(f"No results found for {product} - {target}")
            return
        
        # Get the data
        product_data = self.df[self.df[self.product_col] == product].copy()
        series = product_data.set_index(self.date_col)[target].dropna()
        
        if len(series) == 0:
            return
        
        # Create the plot
        fig, axes = plt.subplots(4, 1, figsize=(15, 12))
        fig.suptitle(f'Shift Detection Comparison: {product} - {target}', fontsize=14, fontweight='bold')
        
        # Plot 1: Original series with changepoint detection
        ax1 = axes[0]
        ax1.plot(series.index, series.values, 'b-', linewidth=1.5, alpha=0.8, label='Original Data')
        
        method_data = self.shift_results[product][target]
        
        if 'changepoint' in method_data and 'shifts' in method_data['changepoint']:
            changepoints = method_data['changepoint']['shifts'].get('combined', [])
            for cp in changepoints:
                ax1.axvline(cp, color='red', linestyle='--', alpha=0.7, linewidth=2)
        
        ax1.set_title('Changepoint Detection (Ruptures)')
        ax1.set_ylabel(target)
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # Plot 2: Statistical tests
        ax2 = axes[1]
        ax2.plot(series.index, series.values, 'b-', linewidth=1.5, alpha=0.8, label='Original Data')
        
        if 'statistical' in method_data and 'shifts' in method_data['statistical']:
            for shift in method_data['statistical']['shifts']:
                ax2.axvline(shift, color='green', linestyle='--', alpha=0.7, linewidth=2)
        
        ax2.set_title('Statistical Tests (t-test & F-test)')
        ax2.set_ylabel(target)
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        
        # Plot 3: EWMA
        ax3 = axes[2]
        ax3.plot(series.index, series.values, 'b-', linewidth=1.5, alpha=0.8, label='Original Data')
        
        if 'ewma' in method_data and 'control_stats' in method_data['ewma']:
            ewma_stats = method_data['ewma']['control_stats']
            ax3.plot(series.index, ewma_stats['ewma'], 'orange', linewidth=2, label='EWMA')
            ax3.plot(series.index, ewma_stats['ucl'], 'r--', alpha=0.7, label='UCL')
            ax3.plot(series.index, ewma_stats['lcl'], 'r--', alpha=0.7, label='LCL')
            
            for shift in method_data['ewma']['shifts']:
                ax3.axvline(shift, color='orange', linestyle='--', alpha=0.7, linewidth=2)
        
        ax3.set_title('EWMA Control Chart')
        ax3.set_ylabel(target)
        ax3.legend()
        ax3.grid(True, alpha=0.3)
        
        # Plot 4: Clustering
        ax4 = axes[3]
        ax4.plot(series.index, series.values, 'b-', linewidth=1.5, alpha=0.8, label='Original Data')
        
        if 'clustering' in method_data and 'shifts' in method_data['clustering']:
            for shift in method_data['clustering']['shifts']:
                ax4.axvline(shift, color='purple', linestyle='--', alpha=0.7, linewidth=2)
        
        # Get consensus shifts
        consensus = self.consensus_shifts(product, target)
        for shift in consensus:
            ax4.axvline(shift, color='black', linestyle='-', alpha=0.9, linewidth=3, label='Consensus')
        
        ax4.set_title('Time Series Clustering + Consensus Shifts')
        ax4.set_ylabel(target)
        ax4.set_xlabel('Date')
        ax4.legend()
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        if save_plots:
            filename = f'shift_comparison_{product}_{target}.png'.replace(' ', '_').replace('%', 'pct')
            plt.savefig(filename, dpi=300, bbox_inches='tight')
        plt.show()
    
    def summary_report(self):
        """
        Generate summary report of all detected shifts
        """
        report = []
        
        for product in self.shift_results:
            for target in self.shift_results[product]:
                consensus_shifts = self.consensus_shifts(product, target)
                
                method_counts = {}
                for method_name, method_result in self.shift_results[product][target].items():
                    if 'shifts' in method_result:
                        if method_name == 'changepoint':
                            count = len(method_result['shifts'].get('combined', []))
                        else:
                            count = len(method_result['shifts'])
                        method_counts[method_name] = count
                
                report.append({
                    'Product': product,
                    'Target': target,
                    'Consensus_Shifts': len(consensus_shifts),
                    'Consensus_Dates': consensus_shifts,
                    **method_counts
                })
        
        return pd.DataFrame(report)

# Example usage
"""
# Initialize the shift detection suite
detector = ShiftDetectionSuite(df, target_vars=['Y1', 'Y2', 'Y3', 'Y4', 'Y5'])

# Detect shifts using all methods
detector.detect_all_shifts()

# Get summary report
summary = detector.summary_report()
print(summary)

# Plot comparison for a specific product and target
detector.plot_comparison('ProductA', 'Y1')

# Get consensus shifts for a specific case
consensus = detector.consensus_shifts('ProductA', 'Y1', min_methods=2)
print(f"Consensus shifts: {consensus}")
"""
